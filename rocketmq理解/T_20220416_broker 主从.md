# 主从
#### pull/push
```
pull 从节点建立2个线程 （请求主节点线程，接受主节点响应线程）
请求线程发送请求 （参数：当前最大偏移量）主节点收到请求后把偏移量之后的数据都拉出来 发送回去 从节点的响应线程接受请求 写数据到磁盘(pageCache->磁盘)

push 主节点写数据时 push给从节点 2/3 成功(pageCache成功就算成功)就算成功
```
#### 消费消息
```
一般都走主节点读，当主节点读压力大时，会返回给客户端从节点id,去从节点消费，从节点消费状况很好时，最终又会回到主节点进行消费

一般mq 都倾向于 主节点做读写，原因：消费进度好维护
      如果读请求被分发到从节点，从节点也会产生消费进度元数据 每隔10s 会同步数据到主节点

```

#### 选举leader过程

```mermaid
graph TD;
a[broker1_状态机]-->b[初始化_状态默认时follower]
b-->c{是否收到leade心跳包}
c--否-->d[随机倒计时切换成候选人]
c--是-->e[别的节点是leader了]
d--随机时间结束-->ee[给自己投票]-->to[发送请求给其他节点请求投票]
to--发送-->ob((其他节点))
ob--返回请求-->to
to-->moreThanHarf{超过半数投票了}
moreThanHarf--否-->resTime[重置计时器]
moreThanHarf--是-->beL[切换成主节点]--定期发送heartBeat请求-->of[给follower节点]
of--响应-->isR{是否收到心跳}--是,再次定期发请求-->beL
isR{是否收到心跳}--否,重新变回candidate参与选举-->d
e-->resTime
```


