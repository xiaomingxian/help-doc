#### kafka rocketMq对比
```
kafka和Rocketmq都是分布式的消息系统，在集群化部署方面，kafka通过zk进行节点协调，而rocketmq通过自身namesrv进行节点协调，所以在协调节点的设计上rocket显得更加轻。
存储方面，
  在Kafka中，
    是1个topic（就是一个业务场景）有多个partition（对应3个物理文件目录），当需要存储数据的时候，会把topic中一个parition大文件分成多个小文件段。
    通过多个小文件段，就轻松实现定期清除或删除已经消费完文件。降低磁盘占用。
  在rocketmq中，
    采用的是混合型的存储结构，即为Broker单个实例下所有的队列共用一个日志数据文件（即为CommitLog）来存储。
  两者在对比上，Kafka采用的是独立型的存储结构，每个队列一个文件。
    RocketMQ采用混合型存储结构的缺点在于，会存在较多的随机读操作，因此读的效率偏低。同时消费消息需要依赖ConsumeQueue，构建该逻辑消费队列需要一定开销。 
    主从备份方面：
      生产者向kafka写入消息时，一般会写入多个分区（partition），kafka提供冗余机制，即每个分区都有多个相同的备份(replica)，
        kafka把分区所有副本均匀分配到其他broker上，并从这些副本中挑选一个作为leader副本对外提供服务，其他副本称为follwer副本。
        当leader副本所在的broker有可能宕机，这时follower副本会竞争成为leader，继续提供服务。 
      而当生产者者向rocketmq写入消息时，会将数据写入集群中的相关master broker上，而每个master broker都有1到多个slave broker,
        这样在一定程度上保证master出现了不可恢复的故障时，不丢失数据。
        同时如果master宕机了，消费者会自动重连到相应的salve上，不会出现消费停滞，
        那么同时在master和slave数据同步分为同步复制(有一定的效率损失)和异步复制(数据不一致) 
   在生产和消费消息方面: 
    在kafka中，每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic，物理上不同Topic的消息分开存储，
    逻辑上一个Topic的消息虽然保存于一个或多个broker上但只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处，而这种能力实现的底层我想应该就是通过zk来完成的。
    在rocketmq中，NameSrv提供
```
#### 客户端如何获取broker信息
 ```
 客户端主动去nameServer拉（定时发送请求去nameServer拉）
 ```
 #### NameServer与Broker互动（30s心跳机制 120s故障感知）
 ```
 broker -30s-> 向NameServer 报告自己活着
 naneS  -10s-> 检测broker最后一次心跳（间隔大于120s认为挂了）
  ```
 
#### 客户端如何感知Broker状态(是不是挂了)？？？
```
```
